% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mthal.R
\name{fit_mthal}
\alias{fit_mthal}
\title{MT-HAL: Multi-Task Highly Adaptive Lasso}
\usage{
fit_mthal(
  X,
  Y,
  type,
  formula = NULL,
  max_degree = ifelse(ncol(X) >= 20, 2, 3),
  smoothness_orders = 1,
  num_knots = num_knots_generator(max_degree = max_degree, smoothness_orders =
    smoothness_orders, base_num_knots_0 = 200, base_num_knots_1 = 50),
  reduce_basis = NULL,
  lambda_1 = NULL,
  fit_control = list(cv_select = TRUE, prediction_bounds = "default"),
  basis_list = NULL,
  return_x_basis = FALSE,
  yolo = FALSE
)
}
\arguments{
\item{X}{A \code{numeric} input \code{matrix} with dimensions number of
observations -by- number of covariates that will be used to derive the
design matrix of basis functions.}

\item{Y}{A \code{numeric} \code{matrix} of observations of the outcomes with
dimensions number of observations -by- number of outcomes. Missingness is
permissible in this matrix, i.e., the number of observations can vary
across the tasks. The outcomes can be binary or continuous. The valid
value of binary outcome \eqn{\in \{1, âˆ’1\}}.}

\item{type}{The type of problem, a \code{character} that must be
\code{"Regression"} or \code{"Classification"}.}

\item{formula}{A character string formula to be used in
\code{\link{formula_hal}}. See its documentation for details.}

\item{max_degree}{The highest order of interaction terms for which basis
functions ought to be generated.}

\item{smoothness_orders}{An \code{integer}, specifying the smoothness of the
basis functions. See details for \code{smoothness_orders} for more
information.}

\item{num_knots}{An \code{integer} vector of length 1 or \code{max_degree},
specifying the maximum number of knot points (i.e., bins) for any covariate
for generating basis functions. If \code{num_knots} is a unit-length
vector, then the same \code{num_knots} are used for each degree (this is
not recommended). The default settings for \code{num_knots} are
recommended, and these defaults decrease \code{num_knots} with increasing
\code{max_degree} and \code{smoothness_orders}, which prevents (expensive)
combinatorial explosions in the number of higher-degree and higher-order
basis functions generated. This allows the complexity of the optimization
problem to grow scalably. See details of \code{num_knots} more information.}

\item{reduce_basis}{An optional \code{numeric} value bounded in the open
unit interval indicating the minimum proportion of 1's in a basis function
column needed for the basis function to be included in the procedure to fit
the regression. Any basis functions with a lower proportion of 1's than the
cutoff will be removed. Defaults to 1 over the square root of the number of
observations. Only applicable for models fit with zero-order splines, i.e.
\code{smoothness_orders = 0}.}

\item{lambda_1}{User-specified sequence of values of the regularization
parameter for the lasso L1 regression, which control cross-task
regularization. If \code{NULL}, the default sequence in
\code{\link[RMTL]{cvMTL}} will be used. The cross-validated
optimal value of this regularization parameter will be selected with
\code{\link[RMTL]{cvMTL}}. If \code{fit_control}'s \code{cv_select}
argument is set to \code{FALSE}, then the regression will be fit via
\code{\link[RMTL]{MTL}}, and regularized coefficient values for each
lambda in the input array will be returned.}

\item{fit_control}{List of arguments, including the following, and any
others to be passed to \code{\link[RMTL]{cvMTL}} or
\code{\link[RMTL]{MTL}}.
\itemize{
\item \code{cv_select}: A \code{logical} specifying if the sequence of
specified \code{lambda_1} values should be passed to
\code{\link[RMTL]{cvMTL}} in order for a single, optimal value of
\code{lambda_1} to be selected according to cross-validation. When
\code{cv_select = FALSE}, a \code{\link[RMTL]{MTL}} model will be
used to fit the sequence of (or single) \code{lambda}.
\item \code{prediction_bounds}: An optional list of vectors of size two
that provides the lower and upper bounds on the predictions for each
outcome. When \code{prediction_bounds = "default"} and
\code{type = "Regression"}, the continuous outcome predictions will be
bounded between \code{min(y) - sd(y)} and \code{max(y) + sd(y)} for each
outcome \code{y}. When \code{type = "Classification"}, the probability of
the individual being assigned to positive label P(y==1) is estimated,
and so \code{prediction_bounds} are ignored.
}}

\item{basis_list}{The full set of basis functions generated from \code{X}.}

\item{return_x_basis}{A \code{logical} indicating whether or not to return
the matrix of (possibly reduced) basis functions used in \code{fit_hal}.}

\item{yolo}{A \code{logical} indicating whether to print one of a curated
selection of quotes from the HAL9000 computer, from the critically
acclaimed epic science-fiction film "2001: A Space Odyssey" (1968).}
}
\value{
Object of class \code{mthal9001}, containing a list of basis
functions, a copy map, coefficients estimated for basis functions,
timing results (for assessing computational efficiency), and the \code{RMTL}
fit object.
}
\description{
Estimation procedure for MT-HAL, Multi-Task Highly Adaptive Lasso
}
\details{
The procedure uses a custom C++ implementation to generate a design
matrix of spline basis functions of covariates and interactions of
covariates. The regularized multivariate regression is fit to this design
matrix via \pkg{RMTL}. The maximum dimension of the design matrix is
\eqn{n} -by- \eqn{(n * 2^(d-1))}, where where \eqn{n} is the number of
observations and \eqn{d} is the number of covariates.

For \code{smoothness_orders = 0}, only zero-order splines (piece-wise
constant) are generated, which assume the true regression function has no
smoothness or continuity. When \code{smoothness_orders = 1}, first-order
splines (piece-wise linear) are generated, which assume continuity of the
true regression function. When \code{smoothness_orders = 2}, second-order
splines (piece-wise quadratic and linear terms) are generated, which assume
a the true regression function has a single order of differentiability.

\code{num_knots} argument specifies the number of knot points for each
covariate and for each \code{max_degree}. Fewer knot points can
significantly decrease runtime, but might be overly simplistic. When
considering \code{smoothness_orders = 0}, too few knot points (e.g., < 50)
can significantly reduce performance. When \code{smoothness_orders = 1} or
higher, then fewer knot points (e.g., 10-30) is actually better for
performance. We recommend specifying \code{num_knots} with respect to
\code{smoothness_orders}, and as a vector of length \code{max_degree} with
values decreasing exponentially. This prevents combinatorial explosions in
the number of higher-degree basis functions generated. The default behavior
of \code{num_knots} follows this logic --- for \code{smoothness_orders = 0},
\code{num_knots} is set to \eqn{500 / 2^{j-1}}, and for
\code{smoothness_orders = 1} or higher, \code{num_knots} is set to
\eqn{200 / 2^{j-1}}, where \eqn{j} is the interaction degree. We also
include some other suitable settings for \code{num_knots} below, all of
which are less complex than default \code{num_knots} and will thus result
in a faster runtime:
\itemize{
\item Some good settings for little to no cost in performance:
\itemize{
\item If \code{smoothness_orders = 0} and \code{max_degree = 3},
\code{num_knots = c(400, 200, 100)}.
\item If \code{smoothness_orders = 1+} and \code{max_degree = 3},
\code{num_knots = c(100, 75, 50)}.
}
\item Recommended settings for fairly fast runtime:
\itemize{
\item If \code{smoothness_orders = 0} and \code{max_degree = 3},
\code{num_knots = c(200, 100, 50)}.
\item If \code{smoothness_orders = 1+} and \code{max_degree = 3},
\code{num_knots = c(50, 25, 15)}.
}
\item Recommended settings for fast runtime:
\itemize{
\item If \code{smoothness_orders = 0} and \code{max_degree = 3},
\code{num_knots = c(100, 50, 25)}.
\item If \code{smoothness_orders = 1+} and \code{max_degree = 3},
\code{num_knots = c(40, 15, 10)}.
}
\item Recommended settings for very fast runtime:
\itemize{
\item If \code{smoothness_orders = 0} and \code{max_degree = 3},
\code{num_knots = c(50, 25, 10)}.
\item If \code{smoothness_orders = 1+} and \code{max_degree = 3},
\code{num_knots = c(25, 10, 5)}.
}
}
}
\examples{
n <- 100
p <- 3
x <- xmat <- matrix(rnorm(n * p), n, p)
y_prob <- plogis(3 * sin(x[, 1]) + sin(x[, 2]))
y1 <- rbinom(n=n, size=1, prob=y_prob)
y1[y1==0] <- -1
y2 <- rbinom(n=n, size=1, prob=y_prob)
y2[y2==0] <- -1
Y <- as.matrix(cbind(y1, y2))
mthal_fit <- fit_mthal(X = x, Y = Y, type = "Classification")
}
