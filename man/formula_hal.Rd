% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/formula_hal9001.R
\name{formula_hal}
\alias{formula_hal}
\title{Formula Interface for HAL Fitting Procedure}
\usage{
formula_hal(
  formula,
  X,
  exclusive_dot = FALSE,
  custom_group = NULL,
  smoothness_orders = NULL,
  num_knots = NULL
)
}
\arguments{
\item{formula}{A character string specifying the \code{fit_hal} model. The
format should be of the form "\code{~ h(x) + h(w,x) + h(x,w) + h(x,w,z)}" or
"\code{y ~ h(x) + h(w,x) + h(x,w) + h(x,w,z)}", where \code{w}, \code{x}, \code{z} are column
names in the input matrix \code{X} and \code{y} is an (optionally-supplied)
outcome. That is, the \code{~} is required in the formula, but anything before
\code{~} is omitted. Each term in the formula represents main-term(s) and/or
interaction(s) to be included in the model. See \code{formula} details for
more information.}

\item{X}{An input \code{matrix} with dimensions number of observations -by-
number of covariates that will be used with the \code{formula} and other
arguments defined in \code{\link{fit_hal}} to derive the design matrix of
basis functions.}

\item{exclusive_dot}{A \code{logical} indicator for whether the \code{.} and
\code{.^degree} arguments in the formula should be treated as exclusive or
with respect to the variables already specified in the formula. See details
on \code{exclusive_dot} for more information. As an example, consider the
formula \code{~ h(x,w) + .}. When \code{exclusive_dot} is {TRUE}, the \code{.}
operator adds all one-way basis functions for variables that are remaining
in \code{X} and not yet specified in the formula (i.e., excluding \code{x} and
\code{w}). When \code{exclusive_dot} is \code{FALSE}, the \code{.} operator adds all
one-way basis functions for \emph{all} variables in \code{X} (i.e., including
\code{x}, \code{w}).}

\item{custom_group}{A named \code{list} that represents a grouping of
variables in \code{X}. Each group in the \code{custom_group} list contains
a character vector of column names in \code{X} that belong to that group.
The names of the \code{custom_group} must be single characters of length 1.
See \code{custom_group} details for more information.}

\item{smoothness_orders}{Necessary argument for generating basis functions
from the \code{formula}. See its documentation in \code{\link{fit_hal}}.}

\item{num_knots}{Necessary argument for generating basis functions from the
\code{formula}. See its documentation in \code{\link{fit_hal}}.}
}
\value{
A \code{formula} object.
}
\description{
Formula Interface for HAL Fitting Procedure
}
\details{
This function allows users to specify the functional form/model of
hal9001, similar to \code{\link[stats]{glm}}. The user can specify which
interactions to include, monotonicity constraints, and smoothness
constraints. The function is intended for use within \code{\link{fit_hal}},
and it is called when \code{formula} is supplied to \code{\link{fit_hal}}.
This function returns a \code{formula} object, which includes parameters
for subsequent use in \code{\link{fit_hal}}. In particular, HAL's
\code{formula} object contains the \code{basis_list}, which is used to
create the design matrix of basis functions for lasso fitting, and other
parameters that are used in the lasso regression.

A \code{formula} of "\code{h(x)}" signifies that all main-term (i.e., one-way)
basis functions of the variable \code{x} (in input matrix \code{X}) should be
included in the model. A \code{formula} of "\code{h(x,w)}" specifies that all
two-way interaction basis functions between \code{x} and \code{w} should be included
in the model. Similarly, a \code{formula} of "\code{h(x,w,z)}" specifies that all
three-way interaction basis functions between \code{x}, \code{w}, and \code{z} should be
included in the model. Note that \code{formula = "h(x,y,z)"} will only
construct three-way basis functions for \code{x}, \code{y}, and \code{z}, and not the
two- and one- way basis functions. Input of the form \code{~ .} will generate all
one-term basis functions for variables in \code{X}. Similarly, \code{~ .^2} will
generate all basis functions up to degree 2 (i.e., all one- and two- way
interaction basis functions) for all variables in \code{X}. One can combine
all of the notions above. For example, \code{~ h(x,w,z) + .^2} will generate all
one- and two- way interaction basis functions for all variables in \code{X},
and additionally all the three-way interaction basis functions between
variables \code{w}, \code{x}, and \code{z}.

In \code{formula}, one can also specify monotonicity constraints by
replacing the letter \code{h} with \code{d} (for decreasing) or \code{i} (for increasing).
For example, the \code{formula} could look like "\code{~ i(x) + i(y) + i(x, y)}",
"\code{~ d(x) + d(y) + d(x, y)}", or "\code{~ d(x) + i(y) + h(x, y)}". The letters
\code{h}, \code{i}, and \code{d} specify functional restrictions of each term:
\itemize{
\item \code{h} specifies no constraints on the term.
\item \code{i} specifies the term should be enforced to be monotonically increasing.
\item \code{d} specifies the term should be enforced to be monotonically decreasing.
}

In \code{formula}, ambiguous operations like \code{~ i(x) + .} will use the first
specification of the term in the formula (generally from left to right).
That is, \code{~ i(x) + .} is interpreted as \code{~ i(x) + h(z) + h(w)}, while
\code{~ h(x) + i(x)} is interpreted as \code{~ h(x)}. Note that \code{.} and \code{.^degree}
have the lowest importance and are evaluated last, regardless of their
location in the formula. As a result, \code{ ~ . + i(x)} will be interpreted as
\code{~ i(x) + h(w) + h(z)}, contrary to the previous case.

In \code{formula}, familiar operations such as the \code{:}, \code{*} , and \code{-} are
also supported:
\itemize{
\item \code{:} is a concatenation operator which maps \code{h(x):h(w)} into \code{h(x,w)}, or
\code{h(x):h(w):h(z)} into \code{h(x,w,z)}.
\item \code{*} concatenates and then generates all lower order terms/interactions.
For example, \code{h(x) * h(w)} is mapped into \code{h(x) + h(w) + h(x,w)}, and
\code{h(x) * h(w) * h(z)} into
\code{h(x) + h(w) + h(z) + h(x,w) + h(x,z) + h(z,w) + h(x,w,z)}.
\item \code{-} subtracts/removes the term from the formula. For example,
\code{h(x) + h(w) - h(w)} becomes \code{h(x)}.
Note that the above operations are sensitive to the constraint prefix (\code{h},
\code{i}, and \code{d}). For ambiguous operations like \code{i(x):h(w)}, the unconstrained
prefix \code{h} will be used unless all prefixes in the term are the same. Thus,
\code{i(x):h(w)} becomes \code{h(x,w)}, \code{i(x):i(w):d(z)} becomes \code{h(x,w,z)}, and
\code{i(x):i(w)} becomes \code{i(x,w)}. The above logic is be applied recursively to
\code{*}, so that something like \code{i(x) * h(w) * i(z)} is interpreted as
\code{i(x) + h(w) + i(z) + h(x,w) + i(x,z) + h(w,z) + h(x,w,z)}.
}

Another useful operation in \code{formula} is the wildcard \code{.} operator.
When it's used in a specified term, it will generate all valid terms where
the value of \code{.} is iterated over all variables in \code{X}. As an example,
consider \code{X} with 3 columns \code{x}, \code{w}, and \code{z}. In this scenario,
\code{h(x,.)} is interpreted as \code{h(x,w) + h(x,z)}, \code{h(.,.)} as
\code{h(x,w) + h(x,z) + h(w,z)}, and \code{h(x,w,.)} as \code{h(x,w,z)}. Also, in
\code{formula}, all operations are compatible with one another. For
example, \code{h(.)*h(x)}, \code{h(.):h(x)}, and \code{h(x) - h(.)} are all valid and
behave as expected.

Note that, if \code{exclusive_dot} is {FALSE}, then differently-appearing
formulas can actually be identical. For example,  \code{~ h(x) + .^2} and
\code{~ .^2} specify the same formula (i.e., generating all basis functions up
to degree 2) when \code{exclusive_dot} is {FALSE}. However, if
\code{exclusive_dot} was set to \code{TRUE}, then \code{~ h(x) + .^2} encodes a
different formula than \code{~ .^2}; specifically, \code{~ h(x) + .^2} means to
generate one-way basis functions for the variable \code{x}, and all basis
functions up to degree 2 for all other variables in \code{X} (i.e.,
excluding \code{x}).

The \code{custom_group} allows the user to specify their own wildcard
symbols (e.g., \code{.}); however, the value of the symbol will be iterated over
all variables specified in the user-supplied group. For example, if one sets
\code{custom_group = list("group1" = c("x", "w"), "group2" = c("t","r"))}, then
the formula would be mapped from \code{~ h(group1, group2)} to
\code{~ h(x,t) + h(x,r) + h(w,t) + h(w,r)}, so that all two-way interactions
using one variable from each group are generated. Similarly, \code{~ h(1,r)}
would be mapped to \code{~ h(x,r) + h(w,r)}. Thus, the custom groups operate
exactly as \code{.}, except the possible values are restricted to a specific
group.
}
