% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sal.R
\name{fit_sal}
\alias{fit_sal}
\title{SAL: The Selectively Adaptive Lasso with MARS}
\usage{
fit_sal(
  X,
  Y,
  X_unpenalized = NULL,
  max_degree = 3,
  smoothness_orders = 1,
  num_knots = c(sqrt(n), n^(1/3), n^(1/5)),
  reduce_basis = 1/sqrt(length(Y)),
  family = c("gaussian", "binomial", "poisson", "cox"),
  lambda = NULL,
  id = NULL,
  weights = NULL,
  offset = NULL,
  fit_control = list(cv_select = TRUE, use_min = TRUE, lambda.min.ratio = 1e-04,
    prediction_bounds = "default"),
  variable_selection_only = FALSE,
  max_degree_MARS = max_degree,
  ...
)
}
\arguments{
\item{X}{An input \code{matrix} with dimensions number of observations -by-
number of covariates that will be used to derive the design matrix of basis
functions.}

\item{Y}{A \code{numeric} vector of observations of the outcome variable.}

\item{X_unpenalized}{An input \code{matrix} with the same number of rows as
\code{X}, for which no L1 penalization will be performed. Note that
\code{X_unpenalized} is directly appended to the design matrix; no basis
expansion is performed on \code{X_unpenalized}.}

\item{max_degree}{The highest order of interaction terms for which basis
functions ought to be generated.}

\item{smoothness_orders}{An \code{integer}, specifying the smoothness of the
basis functions. See details for \code{smoothness_orders} for more
information.}

\item{num_knots}{An \code{integer} vector of length 1 or \code{max_degree},
specifying the maximum number of knot points (i.e., bins) for any covariate
for generating basis functions. If \code{num_knots} is a unit-length
vector, then the same \code{num_knots} are used for each degree (this is
not recommended). The default settings for \code{num_knots} are
recommended, and these defaults decrease \code{num_knots} with increasing
\code{max_degree} and \code{smoothness_orders}, which prevents (expensive)
combinatorial explosions in the number of higher-degree and higher-order
basis functions generated. This allows the complexity of the optimization
problem to grow scalably. See details of \code{num_knots} more information.}

\item{reduce_basis}{A \code{numeric} value bounded in the open unit interval
indicating the minimum proportion of 1's in a basis function column needed
for the basis function to be included in the procedure to fit the lasso.
Any basis functions with a lower proportion of 1's than the cutoff will be
removed. When \code{reduce_basis} is set to \code{NULL}, all basis
functions are used in the lasso-fitting stage of \code{fit_hal}.}

\item{family}{A \code{character} or a \code{\link[stats]{family}} object
(supported by \code{\link[glmnet]{glmnet}}) specifying the error/link
family for a generalized linear model. \code{character} options are limited
to "gaussian" for fitting a standard penalized linear model, "binomial" for
penalized logistic regression, "poisson" for penalized Poisson regression,
and "cox" for a penalized proportional hazards model. Note that passing in
family objects leads to slower performance relative to passing in a
character family (if supported). For example, one should set
\code{family = "binomial"} instead of \code{family = binomial()} when
calling \code{fit_hal}.}

\item{lambda}{User-specified sequence of values of the regularization
parameter for the lasso L1 regression. If \code{NULL}, the default sequence
in \code{\link[glmnet]{cv.glmnet}} will be used. The cross-validated
optimal value of this regularization parameter will be selected with
\code{\link[glmnet]{cv.glmnet}}. If \code{fit_control}'s \code{cv_select}
argument is set to \code{FALSE}, then the lasso model will be fit via
\code{\link[glmnet]{glmnet}}, and regularized coefficient values for each
lambda in the input array will be returned.}

\item{id}{A vector of ID values that is used to generate cross-validation
folds for \code{\link[glmnet]{cv.glmnet}}. This argument is ignored when
\code{fit_control}'s \code{cv_select} argument is \code{FALSE}.}

\item{weights}{observation weights; defaults to 1 per observation.}

\item{offset}{a vector of offset values, used in fitting.}

\item{fit_control}{List of arguments, including the following, and any
others to be passed to \code{\link[glmnet]{cv.glmnet}} or
\code{\link[glmnet]{glmnet}}.
\itemize{
\item \code{cv_select}: A \code{logical} specifying if the sequence of
specified \code{lambda} values should be passed to
\code{\link[glmnet]{cv.glmnet}} in order for a single, optimal value of
\code{lambda} to be selected according to cross-validation. When
\code{cv_select = FALSE}, a \code{\link[glmnet]{glmnet}} model will be
used to fit the sequence of (or single) \code{lambda}.
\item \code{use_min}: Specify the choice of lambda to be selected by
\code{\link[glmnet]{cv.glmnet}}. When \code{TRUE}, \code{"lambda.min"} is
used; otherwise, \code{"lambda.1se"}. Only used when
\code{cv_select = TRUE}.
\item \code{lambda.min.ratio}: A \code{\link[glmnet]{glmnet}} argument
specifying the smallest value for \code{lambda}, as a fraction of
\code{lambda.max}, the (data derived) entry value (i.e. the smallest value
for which all coefficients are zero). We've seen that not setting
\code{lambda.min.ratio} can lead to no \code{lambda} values that fit the
data sufficiently well.
\item \code{prediction_bounds}: A vector of size two that provides the lower
and upper bounds for predictions. When
\code{prediction_bounds = "default"}, the predictions are bounded between
\code{min(Y) - sd(Y)} and \code{max(Y) + sd(Y)}. Bounding ensures that
there is no extrapolation, and it is necessary for cross-validation
selection and/or Super Learning.
}}

\item{variable_selection_only}{Boolean variable. If TRUE then MARS is only used to select variables
and is not used to learn interactions.
If TRUE then all basis functions as specified by the parameters \code{max_degree} and \code{num_knots}
are generated for variables selected by MARS.
The parameter \code{max_degree_MARS} can be used to set max degree interaction of MARS model for variable selection.}

\item{max_degree_MARS}{Only used if \code{variable_selection_only} is set to \code{TRUE}. The max degree interaction of MARS model used for variable selection.}
}
\value{
Object of class \code{hal9001}, containing a list of basis
functions, a copy map, coefficients estimated for basis functions, and
timing results (for assessing computational efficiency).
}
\description{
Estimation procedure for SAL, the Selectively Adaptive Lasso
}
\details{
The procedure implements a greedy version of HAL that uses the
multivariate adaptive regression splines (MARS) implementation of \code{\link[earth]{earth}}
for variable selection and variable subgroup selection for HAL interactions.
By using MARS to learn the structural form of the regression in a greedy manner,
SAL is able to run much faster than standard HAL
and provides relatively quick solutions in large samples and moderately high dimensions.
}
\examples{
n <- 100
p <- 3
x <- xmat <- matrix(rnorm(n * p), n, p)
y_prob <- plogis(3 * sin(x[, 1]) + sin(x[, 2]))
y <- rbinom(n = n, size = 1, prob = y_prob)
sal_fit <- fit_sal(X = x, Y = y, family = "binomial", max_degree = 3)
preds <- predict(sal_fit, new_data = x)
}
