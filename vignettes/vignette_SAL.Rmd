---
title: "Fitting the Selectively Adaptive Lasso with `hal9001`"
author: "[Nima Hejazi](https://nimahejazi.org), [Jeremy
  Coyle](https://github.com/jeremyrcoyle), Rachael Phillips, Lars van der Laan"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: ../inst/REFERENCES.bib
vignette: >
  %\VignetteIndexEntry{Fitting the Selectively Adaptive Lasso with hal9001}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Introduction

The _highly adaptive Lasso_ (HAL) is a flexible machine learning algorithm that
nonparametrically estimates a function based on available data by embedding a
set of input observations and covariates in an extremely high-dimensional space
(i.e., generating basis functions from the available data). For an input data
matrix of $n$ observations and $d$ covariates, the maximum number of zero-order
basis functions generated is approximately $n \cdot 2^{d - 1}$. To select a set
of basis functions from among the (possibly reduced/screener) set that's
generated, the lasso is employed. The `hal9001` R package [@hejazi2020hal9001;
@coyle-gh-hal9001] provides an efficient implementation of this routine, relying
on the `glmnet` R package [@friedman2010glmnet] for compatibility with the
canonical Lasso implementation and using lasso regression with an input matrix
composed of basis functions. Consult @benkeser2016hal, @vdl2015generally,
@vdl2017finite for detailed theoretical descriptions of HAL and its various
optimality properties.

The _selectively adaptive Lasso_ (HAL) is a greedy version of HAL that uses multivariate adaptive regression splines (MARS) to learn important variables and variable interactions. This leads to a substantial speedup relative to HAL and can lead to better performance.

---

## Preliminaries

```{r sim-data}
library(data.table)

# simulation constants

set.seed(1234)
n <- 500
d <- 100
X <- replicate(d, runif(n))
colnames(X) <- paste0("X", 1:d)
mu <- 5 * (sin(3 * X[, 5]) + sin(3 * X[, 3]) + sin(3 * X[, 1]))
Y <- rnorm(n, mu, 0.5)
out <- fit_sal(X, Y, max_degree = 1, num_knots = 10) # Should take no more than a minute
out$coefs <- as.matrix(out$coefs)
p <- predict(out, new_data = X)
plot(p, mu)
```
